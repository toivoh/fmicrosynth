
mutable struct State
    name
    control
    next
end

function merge_microcode(code_in)
    states = Dict()
    heads = []
    substates = []
    for (opcode, cycles) in Iterators.reverse(code_in)
        next = "INST_NOP"
        for (k, control) in Iterators.reverse(enumerate(cycles))
            control = get_bits(control)
            if k == length(cycles)
                control |= C_INST_DONE
            end

            key = (control, next)
            if haskey(states, key)
                curr = states[key]
            else
                name = k == 1 ? uppercase(string(opcode)) : uppercase(string(opcode,"_",k))
                curr = State(name, control, next)
                states[key] = curr
                if k==1; push!(heads, curr)
                else; push!(substates, curr)
                end
            end
            next = curr.name
        end
    end
    return reverse(vcat(substates, heads))
end

function emit_switch_module(io::IO, name::String, input_name::String, input_bits, output_name, output_bits, mapping)
    print(io, """
        module $(name)(
                input [$(input_bits)-1:0] $(input_name),
                output reg [$(output_bits)-1:0] $(output_name)
            );
            always @* begin
                case ($(input_name))
        """);
    for (key, value) in mapping
        println(io, "            $(key): $(output_name) = $(value);")
    end
    print(io, """
                endcase
            end
        endmodule
        """);
end

function emit_enum(io::IO, enum)
    for value in instances(enum)
        println(io, "`define $(value) $(Int(value))")
    end
end

function emit_constants(io::IO, mapping)
    for (name, value) in mapping
        println(io, "`define $(name) $(value)")
    end
end

function control2text(control::Int)
    strs = [result_sel_to_name[get_res(control)]]
    flags = get_flags(control)
    for i=0:max_control_bit_index
        if flags & (1<<i) != 0
            push!(strs, " | ", control_bit_to_name[i])
        end
    end
    return prod(strs)
end

function encode_instruction(inst::Instruction)
    opcode::Int = Int(inst.op)
    scale_code::Int = inst.context.n + 13
    addr::Int = inst.context.addr

    @assert 0 <= opcode <= 15
    @assert 0 <= scale_code <= 15
    @assert 0 <= addr <= 63

    return (opcode << 12) | (scale_code << 8) | addr;
end

result_sel_pairs = [(uppercase(string(key)), value) for (key, value) in result_selections]
control_flag_pairs = [(uppercase(string(key)), value) for (key, value) in control_flags]


result_sel_to_name = Dict((value, string("`", key)) for (key, value) in result_sel_pairs)
control_bit_to_name = Dict((round(Int, log2(value)), string("`", key)) for (key, value) in control_flags)
max_control_bit_index = maximum([key for (key, value) in control_bit_to_name])

# Sort so that the opcode's zero based index in the list corresponds to its value,
# so that the emitted C defines will be consistent with the emitted states
sorted_microcode = [(opcode => opcode_programs[opcode]) for opcode in instances(Opcode)]

inst_names = [uppercase(string(opcode)) for (opcode, cycles) in sorted_microcode]

states = merge_microcode(sorted_microcode)
state_names = [state.name for state in states]
next_states = [("`"*state.name, "`"*state.next) for state in states]
push!(next_states, ("default", "`INST_NOP"))
controls = [("`"*state.name, control2text(state.control)) for state in states]
push!(controls, ("default", controls[1][2]))

state_bits = ceil(Int,log2(length(state_names)))
control_bits = max_control_bit_index+1

function emit_defines(io::IO)
    # Key constants
    emit_constants(io, [("STATE_BITS", state_bits), ("CONTROL_BITS", control_bits), ("RESULT_SEL_BITS", result_sel_bits)])
    println(io, "\n// Result selector codes")
    emit_constants(io, [(key, string(const_sel_bits, "'d", value)) for (key, value) in result_sel_pairs]);
    println(io, "\n// Control flags")
    emit_constants(io, [(key, "(1 << $(round(Int, log2(value))))") for (key, value) in control_flags]);
    println(io, "\n// States")
    for (k, name) in enumerate(state_names)
        println(io, "`define $(name) $(k-1)")
    end
end

function emit_state_machine_code(io::IO)
    emit_switch_module(io, "fms_next_state_function", "state", "`STATE_BITS", "next_state", "`STATE_BITS", next_states)
    println(io)
    emit_switch_module(io, "fms_control_function", "state", "`STATE_BITS", "control", "`CONTROL_BITS", controls)
end

function emit_instruction_defines(io::IO, instructions)
    print(io, """
        // Generated by julia/codegen.jl -- rerun to regenerate
        #ifndef __instructions_generated_h
        #define __instructions_generated_h

        """)

    max_len = maximum(length(name) for (name, inst) in instructions)

    for (name, inst) in instructions
        inst_code = encode_instruction(inst)
        pad = " "^(max_len - length(name))
        name = "INST_" * uppercase(name)
        println(io, "#define $name$pad 0x$(string(inst_code, base=16, pad=4))")
    end

    print(io, """

        #endif // __instructions_generated_h
        """)
end

emit_defines(stdout)
emit_state_machine_code(stdout)

emit_instruction_defines(stdout, instructions)

if true
    open("../fmicrosynth_generated.vh", "w") do io
        print(io, """
            // Generated by julia/codegen.jl -- rerun to regenerate

            `ifndef __fmicrosynth_generated_vh
            `define __fmicrosynth_generated_vh

            """)
        emit_defines(io)
        println(io, "\n`endif // __fmicrosynth_generated_vh")
    end
    open("../fmicrosynth_generated.v", "w") do io
        print(io, """
            // Generated by julia/codegen.jl -- rerun to regenerate
            `include "fmicrosynth_generated.vh"

            """)
        emit_state_machine_code(io)
    end
end

open("../c/instructions_generated.h", "w") do io
    emit_instruction_defines(io, instructions)    
end
